l1=['1', 'd', 'D', 'BDb', 'cdc', 'Ada', 'c^2', 'cDC', 'aDa', 'CdC', 'AdA', 'b^2', 'd^2', 'BdB', 'ada', 'BDB', 'D^2', 'bDB', 'adA', 'a^2', 'cDc', 'Cdc', 'cdC', 'D^3', 'ADA', 'CDc', 'aDA', 'B^2', 'Bdb', 'd^3', 'C^2', 'A^2', 'bdb', 'bDb', 'bdB', 'CDC', 'ADa', 'a^2D', 'b^2D', 'dc^2', 'dA^2', 'Dc^2', 'db^2', 'da^2', 'C^2D', 'dB^2', 'c^2d', 'DB^2', 'C^2d', 'DA^2', 'Db^2', 'B^2d', 'DC^2', 'a^2d', 'b^2d', 'A^2d', 'c^2D', 'A^2D', 'Da^2', 'dC^2', 'B^2D']
l2=['d', 'D', '1', 'D^2', 'A^2', 'aDa', 'b^4', 'ada', 'BDb', 'AdA', 'cDC', 'B^2', 'c^4', 'Ada', 'CdC', 'bdB', 'bDb', 'C^2', 'D^3', 'Cdc', 'd^4', 'b^2', 'B^4', 'bdb', 'A^4', 'adA', 'c^2', 'bDB', 'CDc', 'D^4', 'd^2', 'cDc', 'a^4', 'CDC', 'BDB', 'cdC', 'ADa', 'a^2', 'aDA', 'cdc', 'ADA', 'Bdb', 'C^4', 'd^3', 'BdB', 'dcDc', 'ACAC', 'dcdc', 'dC^2', 'DaDA', 'DaDa', 'cAca', 'dADa', 'bdBd', 'cdCd', 'Bdbd', 'Caca', 'caca', 'B^2d', 'CbcB', 'CDcd', 'Adad', 'BdbD', 'b^2d', 'DADA', 'Dcdc', 'Acac', 'c^2d', 'aDAd', 'bDbD', 'dB^2', 'dBDB', 'dbDB', 'a^2d', 'bCBc', 'Dbdb', 'Da^2', 'CBcB', 'CBcb', 'cBcb', 'bCbC', 'a^2D', 'CDCD', 'Bcbc', 'aCac', 'cBcB', 'AdaD', 'DA^2', 'acaC', 'BCBc', 'dbdB', 'BdBD', 'BCbc', 'cdCD', 'Db^2', 'cDcD', 'CacA', 'bcbc', 'cDCd', 'DcDc', 'bDbd', 'CdcD', 'cdcD', 'dBdb', 'bDBD', 'A^2d', 'DCdc', 'adad', 'bcBc', 'b^2D', 'AcAc', 'dada', 'bdbd', 'CAcA', 'DbDb', 'C^2D', 'dAda', 'bCBC', 'DC^2', 'aCAc', 'adAd', 'CACa', 'BDbD', 'dA^2', 'daDA', 'bcbC', 'cbCb', 'DADa', 'DbDB', 'DBDB', 'db^2', 'dBdB', 'DCDC', 'Dc^2', 'BcBc', 'DCdC', 'BCbC', 'dc^2', 'da^2', 'Cbcb', 'dCDc', 'DcDC', 'BcBC', 'dbDb', 'CbCB', 'CACA', 'dCDC', 'c^2D', 'acAC', 'CdCD', 'caCA', 'bCbc', 'cACA', 'AdAd', 'B^2D', 'DBdb', 'cacA', 'bdbD', 'BdBd', 'ACac', 'adAD', 'bdBD', 'cbCB', 'CBCb', 'ADad', 'cbcb', 'DB^2', 'BDBD', 'ADAd', 'BDBd', 'DBDb', 'CdCd', 'bDBd', 'cDcd', 'dadA', 'AcAC', 'bcBC', 'cdcd', 'ADaD', 'cACa', 'A^2D', 'daDa', 'CbCb', 'C^2d', 'cAcA', 'CaCA', 'dCdc', 'CAca', 'ACAc', 'DadA', 'aCaC', 'acAc', 'cbcB', 'adaD', 'aDad', 'AdAD', 'CBCB', 'DBdB', 'AcaC', 'DbdB', 'DAdA', 'dAdA', 'Dada', 'aCAC', 'DAda', 'BDbd', 'acac', 'dcDC', 'CDcD', 'dcdC', 'CaCa', 'aDAD', 'dADA', 'aDaD', 'caCa', 'dCdC', 'CDCd', 'cBCb', 'ACaC', 'dbdb', 'ADAD', 'DcdC', 'BcbC', 'dBDb', 'Cdcd', 'cDCD', 'DCDc', 'BCBC', 'cBCB', 'Bd^2B', 'Ac^2a', 'Bc^2b', 'bA^2b', 'dB^2d', 'ab^2a', 'BC^2b', 'Ba^2B', 'BD^2B', 'ba^2b', 'CD^2c', 'Dc^2d', 'AB^2A', 'DC^2d', 'Cb^2c', 'Ca^2C', 'Ab^2A', 'DA^2d', 'BD^2b', 'Da^2d', 'Ac^2A', 'cd^2c', 'CA^2C', 'BA^2B', 'aB^2a', 'ca^2c', 'AD^2A', 'Db^2D', 'Cd^2c', 'Ab^2a', 'CB^2c', 'aC^2A', 'bD^2B', 'bC^2b', 'dC^2D', 'BA^2b', 'aC^2a', 'cb^2C', 'ca^2C', 'dA^2D', 'ab^2A', 'ac^2a', 'cA^2c', 'bD^2b', 'dB^2D', 'Bd^2b', 'DB^2D', 'bd^2B', 'cd^2C', 'CD^2C', 'Ad^2A', 'Ad^2a', 'Cb^2C', 'Cd^2C', 'Ba^2b', 'dC^2d', 'Dc^2D', 'AC^2a', 'dc^2D', 'aB^2A', 'Da^2D', 'AC^2A', 'DC^2D', 'DA^2D', 'DB^2d', 'da^2d', 'CA^2c', 'cB^2c', 'da^2D', 'Ca^2c', 'ad^2a', 'BC^2B', 'bC^2B', 'dc^2d', 'cb^2c', 'cD^2c', 'Db^2d', 'AB^2a', 'aD^2a', 'bd^2b', 'db^2D', 'dA^2d', 'Bc^2B', 'CB^2C', 'cA^2C', 'cB^2C', 'ac^2A', 'cD^2C', 'bc^2B', 'ad^2A', 'AD^2a', 'bc^2b', 'aD^2A', 'ba^2B', 'db^2d', 'bA^2B', 'c^2D^2', 'd^2b^2', 'A^2c^2', 'D^2c^2', 'C^2B^2', 'D^2A^2', 'b^2A^2', 'C^2D^2', 'B^2C^2', 'D^2B^2', 'B^2d^2', 'B^2D^2', 'c^2B^2', 'd^2c^2', 'b^2C^2', 'C^2a^2', 'a^2b^2', 'a^2d^2', 'C^2A^2', 'C^2d^2', 'd^2C^2', 'c^2b^2', 'a^2c^2', 'b^2c^2', 'B^2a^2', 'b^2a^2', 'b^2D^2', 'd^2B^2', 'D^2C^2', 'D^2b^2', 'a^2B^2', 'A^2d^2', 'C^2b^2', 'A^2D^2', 'A^2b^2', 'c^2A^2', 'a^2D^2', 'B^2A^2', 'D^2a^2', 'c^2a^2', 'a^2C^2', 'd^2A^2', 'A^2C^2', 'd^2a^2', 'c^2d^2', 'A^2B^2', 'b^2d^2', 'B^2c^2']


from typing import List, Dict, Tuple
import networkx as nx
import numpy as np
import matplotlib.pyplot as plt
import itertools
import csv
from scipy.linalg import eigvals
import numpy as np
from numpy.linalg import eig
from scipy.sparse import csgraph
alphabet = ['0','1']
state = ['a','b','c','d','A','B','C','D','e']
edge = []
d = len(alphabet)
n = len(state)

edge_lable=[('0', ('a', 'd')), ('0', ('b', 'a')), ('0', ('c', 'a')), ('0', ('d', 'e')), ('0', ('A', 'e')), ('0', ('B', 'A')), ('0', ('C', 'A')), ('0', ('D', 'e')), ('0', ('e', 'e')), ('1', ('a', 'e')), ('1', ('b', 'c')), ('1', ('c', 'a')), ('1', ('d', 'b')), ('1', ('A', 'D')), ('1', ('B', 'C')), ('1', ('C', 'A')), ('1', ('D', 'B')), ('1', ('e', 'e'))]

permutation=[('a', ('0', '1')), ('a', ('1', '0')), ('b', ('0', '0')), ('b', ('1', '1')), ('c', ('0', '0')), ('c', ('1', '1')), ('d', ('0', '0')), ('d', ('1', '1')), ('A', ('0', '1')), ('A', ('1', '0')), ('B', ('0', '0')), ('B', ('1', '1')), ('C', ('0', '0')), ('C', ('1', '1')), ('D', ('0', '0')), ('D', ('1', '1')), ('e', ('0', '0')), ('e', ('1', '1'))]

def t(state, letter):
     for i in range(len(edge_lable)):
        if edge_lable[i][0]==letter and edge_lable[i][1][0]==state:
          return edge_lable[i][1][1]

def o(state,letter):
    for i in range(len(permutation)):
        if permutation[i][0]==state and permutation[i][1][0]==letter:
            return permutation[i][1][1]

def transition(state,word):
    if len(word)<=1:
        return t(state,word)
    else:
        return t(transition(state,word[:-1]),word[-1:])

def output(state,word):
    if len(word)<= 1:
        return o(state,word)
    else:
        return output(state,word[:-1])+o(transition(state,word[:-1]),word[-1:])


def super_output(g,word):
    if len(g)<=1:
        return output(g,word)
    else:
        return super_output(g[:-1],output(g[-1:],word))


def super_transition(g, word):
    if len(g)<=1:
        return transition(g,word)
    else:
        return super_transition(g[:-1],super_output(g[-1:],word))+transition(g[-1:],word)

def convertTuple(v):
    u=''
    for x in v:
        u=u+x
    return u

def level(x):
    s=[seq for seq in itertools.product(alphabet, repeat=x)]
    v= []
    for i in s:
        v.append(convertTuple(i))
    return v

exist_identity=False
if 'e' in state:
    exist_identity=True
    state.remove('e')

N=int(input('Enter the maxmial length of stablier element: '))

rep_list1=['aA', 'Aa', 'bB', 'Bb' , 'cC', 'Cc','dD','Dd']+['e']
rep_list2=[]
for x in state:
    u=''
    for i in range(N+1):
     u = u+x
     rep_list2.append(u)

for x in rep_list2:
    if len(x)==1:
        rep_list2.remove(x)

rep_list2.sort(reverse=True)
rep_list3=['aA', 'Aa', 'bB', 'Bb' , 'cC', 'Cc','dD','Dd']
def rep_fun(s):
    for x in rep_list1:
        s = s.replace(x, '')
    for x in rep_list2:
          s=s.replace(x, x[0]+'^'+str(len(x)))
    if s=='':
        return '1'
    else:
     return s

def weaker_rep_fun(s):
    for x in rep_list1:
        s = s.replace(x, '')
    if s == '':
       return '1'
    else:
       return s

def generate_words(letters, max_length, prohibited_patterns):
    words = []
    for length in range(1, max_length + 1):
        for combination in itertools.product(letters, repeat=length):
            word = ''.join(combination)
            if any(pattern in word for pattern in prohibited_patterns):
                continue
            words.append(word)
    return words


generator=generate_words(state,N,rep_list1)


automaton_edge=[]
if exist_identity==True:
    state.append('e')
for x in state:
    for y in alphabet:
        automaton_edge.append((x, super_transition(x,y),y+'|'+ super_output(x,y)))
print('The automaton: ')
print(automaton_edge)
def vertex_stablizer(vertex,n):
    s=[]
    for j in generate_words(state,n,rep_list3):
        if vertex==super_output(j , vertex):
            s.append(weaker_rep_fun(j))
    return sorted(list(dict.fromkeys(s)),key=len)
l=int(input('Enter the level of the tree: '))


def list_intersection(lists):
    # Convert each inner list to a set
    sets = [set(lst) for lst in lists]

    # Calculate the intersection of all sets using the `&` operator
    intersection_set = set.intersection(*sets)

    # Convert the intersection set back to a list
    intersection_list = list(intersection_set)

    return intersection_list

def iterative_weaker__replace_function(word):
    w=word
    for i in range(0,N*8):
        w=weaker_rep_fun(w)
    return w
def iterative_replace_function(word):
    w=word
    for i in range(0,N*8):
        w=weaker_rep_fun(w)
    return rep_fun(w)


def level_stablizer(l,integer):
    return list_intersection([vertex_stablizer(x,integer) for x in level(l)])


U=list(dict.fromkeys(list(map(iterative_weaker__replace_function,level_stablizer(l,N)))))
u=list(dict.fromkeys(list(map(iterative_weaker__replace_function,level_stablizer(l,N-1)))))


print('stablizer of level '+ str(l)+ 'with length '+ str(N-1))
print(sorted(u,key=len))
print('stablizer of level '+ str(l)+ 'with length '+ str(N))

print(sorted(U,key=len))

def inverse_fun(x):
    if x==x.upper():
        y=x.lower()
    else:
        y=x.upper()
    return y

def super_inverse_fun(w):
    if len(w)==1:
        return inverse_fun(w)
    else:
        x1=w[0]
        x2=w[1:]
        y=super_inverse_fun(x2)+inverse_fun(x1)
        return y

def inverse_reducer(list):
    L=[]

    while len(list) >= 1:
        L.append(list[0])
        x = list[0]
        list.remove(list[0])
        if super_inverse_fun(x) in list:
            list.remove(super_inverse_fun(x))
    return L

def reducer(word,list):
    for x in list:
        word=word.replace(x, '1')
    return word

def generator_finder(lagerlist,smallerlist):
    res = [i for i in lagerlist if i not in smallerlist]
    due = [i for i in res if not (reducer(i, u).replace('1', '') == '' or iterative_weaker__replace_function(reducer(i, u).replace('1', '')) == '1')]
    return due

print(generator_finder(U,u))
print(list(map(super_inverse_fun,inverse_reducer(sorted(generator_finder(U,u))))))